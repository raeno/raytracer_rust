### Raytracer. Глава 1.

Завершил первую главу. Почти месяц ушел на то, чтобы сделать базовый Tuple и операции над ним, но когда их победил - остальное стало проще.

Все последующие операции ( dot, crossproduct, magnitude ) во многом операются на базовые и воплощаются уже проще. Понял, что удобно их делать через создание trait и реализации имплементации под конкретную структуру Tuple. В этом есть некая близость traits в Rust с идее миксинов в Ruby. Технически, это очень разные вещи, ruby подмешивает динамически mixins прямо в тот же класс, но хорошим тоном считается создаваться модули так, чтобы они описывали функциональность, а не принадлежность группе ( например, в руби это было бы Dottable, CrossProductable, etc )

Долго доходила невозможность создания разных версий функции на базе Traits. То есть можно сделать 
`impl Dot for Tuple<i32>` и `impl Dot for Tuple<f64>` и оно будет работать, но если мы делаем `impl<T: Int> Dot for Tuple<T>` и `impl<T: Float> Dot for Tuple<T>`, то rust начнет ругаться.
Это непривычно поначалу, но потом понял, что если нечто реализует и Int и Float, то компилятор не сможет разобраться какую реализацию ему выбрать.

